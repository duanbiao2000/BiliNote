## BiliNote 学习教程（从入门到二开）

- 目标读者：想要本地运行、理解原理并进行二次开发的同学
- 你将学会：本地运行/容器部署、任务流程与数据流、后端/前端代码结构、扩展下载器/转写/模型、常见问题排查

---

## 一、快速认识项目

- 定位：AI 视频笔记生成工具，支持 Bilibili/YouTube/抖音/本地视频，多模态理解 + Markdown 输出
- 技术栈
  - 后端：FastAPI（`backend/`）
  - 前端：Vite + React + TypeScript（`BillNote_frontend/`）
  - 部署：Docker Compose + Nginx（`docker-compose.yml`，`nginx/`）
- 文档与演示
  - 使用文档：`https://docs.bilinote.app/`
  - 在线体验：`https://www.bilinote.app/`

---

## 二、环境准备与启动

- 必备：Python 3.10+、Node.js 18+、pnpm、ffmpeg（加入 PATH）
- Windows 路径不要包含中文

本地开发（推荐）：

```bash
git clone https://github.com/JefferyHcool/BiliNote.git
cd BiliNote
mv .env.example .env  # 若无该文件可手动创建 .env

# 启动后端
cd backend
pip install -r requirements.txt
python main.py

# 启动前端
cd ../BillNote_frontend
pnpm install
pnpm dev
# 访问 http://localhost:5173
```

Docker 一键部署（含 Nginx 汇总）：

```bash
docker compose up -d --build
# 访问 http://localhost:${APP_PORT}
```

---

## 三、代码导读（后端 Back-end）

本节按「入口 → 路由 → 服务编排 → 领域组件 → 数据访问层」逐层展开，代码片段含教育性注释，便于 code review。

### 3.1 应用入口与生命周期（FastAPI 初始化）

要点：
- 生命周期里初始化数据库、转写器、默认模型提供方；
- 挂载静态资源目录 `/static` 与 `/uploads`；
- 配置 CORS 允许本地前端与 Tauri 调试；

```1:77:backend/main.py
import os
from contextlib import asynccontextmanager

import uvicorn
from fastapi import FastAPI
from starlette.middleware.cors import CORSMiddleware
from starlette.staticfiles import StaticFiles
from dotenv import load_dotenv

from app.db.init_db import init_db
from app.db.provider_dao import seed_default_providers
from app.exceptions.exception_handlers import register_exception_handlers
from app.utils.logger import get_logger
from app import create_app
from app.transcriber.transcriber_provider import get_transcriber
from events import register_handler

logger = get_logger(__name__)
load_dotenv()

# 读取静态目录配置（教育注释：优先读 .env，便于容器化/不同环境切换）
static_path = os.getenv('STATIC', '/static')
out_dir = os.getenv('OUT_DIR', './static/screenshots')

# 在启动前确保必要目录存在（教育注释：避免首次运行报错）
static_dir = "static"
uploads_dir = "uploads"
if not os.path.exists(static_dir):
    os.makedirs(static_dir)
if not os.path.exists(uploads_dir):
    os.makedirs(uploads_dir)
if not os.path.exists(out_dir):
    os.makedirs(out_dir)

@asynccontextmanager
async def lifespan(app: FastAPI):
    # 教育注释：这里统一做一次性启动任务（注册事件、建表、注入转写器、种子数据）
    register_handler()
    init_db()
    get_transcriber(transcriber_type=os.getenv("TRANSCRIBER_TYPE", "fast-whisper"))
    seed_default_providers()
    yield

app = create_app(lifespan=lifespan)
origins = ["http://localhost", "http://127.0.0.1", "http://tauri.localhost"]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
register_exception_handlers(app)
app.mount(static_path, StaticFiles(directory=static_dir), name="static")
app.mount("/uploads", StaticFiles(directory=uploads_dir), name="uploads")

if __name__ == "__main__":
    port = int(os.getenv("BACKEND_PORT", 8483))
    host = os.getenv("BACKEND_HOST", "0.0.0.0")
    logger.info(f"Starting server on {host}:{port}")
    uvicorn.run(app, host=host, port=port, reload=False)
```

### 3.2 路由：提交任务、上传与状态轮询

要点：
- `POST /generate_note`：生成任务 ID，使用 `BackgroundTasks` 异步执行；
- `GET /task_status/{task_id}`：读取状态/结果文件，前端轮询使用；
- `POST /upload`：本地文件上传，返回 `/uploads/xxx` 路径；

```1:200:backend/app/routers/note.py
# 省略 import（见完整文件）
router = APIRouter()

class VideoRequest(BaseModel):
    # 教育注释：前端传入的任务参数，包含平台/质量/模型/输出格式等
    video_url: str
    platform: str
    quality: DownloadQuality
    screenshot: Optional[bool] = False
    link: Optional[bool] = False
    model_name: str
    provider_id: str
    task_id: Optional[str] = None
    format: Optional[list] = []
    style: str = None
    extras: Optional[str]=None
    video_understanding: Optional[bool] = False
    video_interval: Optional[int] = 0
    grid_size: Optional[list] = []

@router.post("/generate_note")
def generate_note(data: VideoRequest, background_tasks: BackgroundTasks):
    # 教育注释：复用 task_id 支持“重试”；否则生成新的 task_id
    # 将耗时的生成流程丢给 background_tasks，接口快速返回 task_id
    ...

@router.get("/task_status/{task_id}")
def get_task_status(task_id: str):
    # 教育注释：优先读 {task_id}.status.json（阶段状态），完成后读 {task_id}.json（最终结果）
    ...
```

完整实现参见文件，建议在 code review 时重点关注：
- 参数校验（`field_validator` 与平台 URL 校验）；
- 后台任务入队与异常处理；
- 返回结构统一包裹 `ResponseWrapper`；

### 3.3 任务编排核心：下载 → 转写 → 总结 → 后处理 → 入库

要点：
- 每个阶段更新 `{task_id}.status.json`，前端据此展示步骤；
- 下载阶段可选是否需要视频（截图/多模态）；
- 总结阶段拼装 Prompt，支持格式、风格、图片输入；

```62:118:backend/app/services/note.py
class NoteGenerator:
    """
    教育注释：单个任务的完整生命周期封装器，确保：
    - 阶段可追踪（状态文件）；
    - 可缓存（音频/转写/Markdown 缓存文件）；
    - 可扩展（下载器/转写器/GPT 工厂化）。
    """

    def __init__(self):
        self.transcriber_type: str = os.getenv("TRANSCRIBER_TYPE", "fast-whisper")
        self.transcriber: Transcriber = self._init_transcriber()
        self.video_path: Optional[Path] = None
        self.video_img_urls=[]

    def generate(
        self,
        video_url: Union[str, HttpUrl],
        platform: str,
        quality: DownloadQuality = DownloadQuality.medium,
        task_id: Optional[str] = None,
        model_name: Optional[str] = None,
        provider_id: Optional[str] = None,
        link: bool = False,
        screenshot: bool = False,
        _format: Optional[List[str]] = None,
        style: Optional[str] = None,
        extras: Optional[str] = None,
        output_path: Optional[str] = None,
        video_understanding: bool = False,
        video_interval: int = 0,
        grid_size: Optional[List[int]] = None,
    ) -> NoteResult | None:
        # 教育注释：阶段 0 - 记录解析中
        self._update_status(task_id, TaskStatus.PARSING)
        # 选择下载器与 GPT（工厂/服务抽象，便于扩展与替换）
        downloader = self._get_downloader(platform)
        gpt = self._get_gpt(model_name, provider_id)
        # 建立缓存文件（教育注释：重复任务直接读缓存可显著加速）
        audio_cache_file = NOTE_OUTPUT_DIR / f"{task_id}_audio.json"
        transcript_cache_file = NOTE_OUTPUT_DIR / f"{task_id}_transcript.json"
        markdown_cache_file = NOTE_OUTPUT_DIR / f"{task_id}_markdown.md"
        # 阶段 1 - 下载
        audio_meta = self._download_media(
            downloader=downloader,
            video_url=video_url,
            quality=quality,
            audio_cache_file=audio_cache_file,
            status_phase=TaskStatus.DOWNLOADING,
            platform=platform,
            output_path=output_path,
            screenshot=screenshot,
            video_understanding=video_understanding,
            video_interval=video_interval,
            grid_size=grid_size,
        )
        # 阶段 2 - 转写
        transcript = self._transcribe_audio(
            audio_file=audio_meta.file_path,
            transcript_cache_file=transcript_cache_file,
            status_phase=TaskStatus.TRANSCRIBING,
        )
        # 阶段 3 - GPT 总结（可携带图片 URL 实现多模态）
        markdown = self._summarize_text(
            audio_meta=audio_meta,
            transcript=transcript,
            gpt=gpt,
            markdown_cache_file=markdown_cache_file,
            link=link,
            screenshot=screenshot,
            formats=_format or [],
            style=style,
            extras=extras,
            video_img_urls=self.video_img_urls,
        )
        # 阶段 4 - 后处理（插入截图/原片跳转）
        if _format:
            markdown = self._post_process_markdown(
                markdown=markdown,
                video_path=self.video_path,
                formats=_format,
                audio_meta=audio_meta,
                platform=platform,
            )
        # 阶段 5/6 - 入库与完成
        self._update_status(task_id, TaskStatus.SAVING)
        self._save_metadata(video_id=audio_meta.video_id, platform=platform, task_id=task_id)
        self._update_status(task_id, TaskStatus.SUCCESS)
        return NoteResult(markdown=markdown, transcript=transcript, audio_meta=audio_meta)
```

### 3.4 下载器抽象与 B 站实现（yt_dlp）

要点：
- `Downloader` 约定 `download`（音频）与 `download_video`（视频）；
- B 站实现选用最佳音频并转 mp3，视频合并为 mp4；

```16:39:backend/app/downloaders/base.py
class Downloader(ABC):
    # 教育注释：为不同平台提供统一的下载接口，便于在服务层按平台动态选择实现
    @abstractmethod
    def download(self, video_url: str, output_dir: str = None,
                 quality: DownloadQuality = "fast", need_video: Optional[bool] = False) -> AudioDownloadResult:
        pass

    @staticmethod
    def download_video(self, video_url: str,
                       output_dir: Union[str, None] = None) -> str:
        pass
```

```13:63:backend/app/downloaders/bilibili_downloader.py
class BilibiliDownloader(Downloader, ABC):
    def download(
        self,
        video_url: str,
        output_dir: Union[str, None] = None,
        quality: DownloadQuality = "fast",
        need_video:Optional[bool]=False
    ) -> AudioDownloadResult:
        # 教育注释：选用 bestaudio；postprocessors 用 ffmpeg 抽出 mp3，质量 64kbps
        ydl_opts = {
            'format': 'bestaudio[ext=m4a]/bestaudio/best',
            'outtmpl': os.path.join(output_dir, "%(id)s.%(ext)s"),
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': 'mp3',
                'preferredquality': '64',
            }],
            'noplaylist': True,
            'quiet': False,
        }
        ...

    def download_video(self, video_url: str, output_dir: Union[str, None] = None) -> str:
        # 教育注释：视频选择 mp4 并合并音视频（merge_output_format: mp4）
        ydl_opts = {
            'format': 'bv*[ext=mp4]/bestvideo+bestaudio/best',
            'outtmpl': os.path.join(output_dir, "%(id)s.%(ext)s"),
            'noplaylist': True,
            'quiet': False,
            'merge_output_format': 'mp4',
        }
        ...
```

### 3.5 转写器示例：Whisper（faster-whisper）

要点：
- 自动判断 GPU 能力，选择 compute_type；
- 首次运行自动下载指定大小模型到本地缓存；

```33:75:backend/app/transcriber/whisper.py
class WhisperTranscriber(Transcriber):
    def __init__(self, model_size: str = "base", device: str = 'cpu', compute_type: str = None, cpu_threads: int = 1):
        # 教育注释：优先使用 CUDA；否则退化为 CPU（int8 提升速度）
        self.compute_type = compute_type or ("float16" if self.device == "cuda" else "int8")
        # 下载/加载本地模型（教育注释：模型目录统一由 path_helper 管理）
        model_dir = get_model_dir("whisper")
        model_path = os.path.join(model_dir, f"whisper-{model_size}")
        if not Path(model_path).exists():
            # 教育注释：使用 modelscope 拉取对应仓库，加速国内可用性
            repo_id = MODEL_MAP[model_size]
            model_path = snapshot_download(repo_id, local_dir=model_path)
        self.model = WhisperModel(model_size_or_path=model_path, device=self.device, compute_type=self.compute_type, download_root=model_dir)
```

### 3.6 Prompt 组装与多模态输入

要点：
- `generate_base_prompt` 按格式与风格动态拼装；
- UniversalGPT 将 `text + image_url` 混合放入同一消息；

```23:44:backend/app/gpt/prompt_builder.py
def generate_base_prompt(title, segment_text, tags, _format=None, style=None, extras=None):
    # 教育注释：最小 Prompt 由标题+时间轴文本+标签构成；
    # 其后串接格式功能（目录/跳转/截图/总结）与风格描述（学术/教程等）。
    prompt = BASE_PROMPT.format(video_title=title, segment_text=segment_text, tags=tags)
    if _format:
        prompt += "\n" + "\n".join([get_format_function(f) for f in _format])
    if style:
        prompt += "\n" + get_style_format(style)
    if extras:
        prompt += f"\n{extras}"
    return prompt
```

```31:61:backend/app/gpt/universal_gpt.py
def create_messages(self, segments: List[TranscriptSegment], **kwargs):
    # 教育注释：按 OpenAI 兼容接口构造 messages，支持图文混排
    content_text = generate_base_prompt(...)
    content = [{"type": "text", "text": content_text}]
    for url in kwargs.get('video_img_urls', []):
        content.append({"type": "image_url", "image_url": {"url": url, "detail": "auto"}})
    return [{"role": "user", "content": content}]
```

### 3.7 数据模型与 DAO

要点：
- 仅记录 `video_id/platform/task_id/created_at`；
- DAO 提供插入/查询最新/删除接口；

```7:14:backend/app/db/models/video_tasks.py
class VideoTask(Base):
    __tablename__ = "video_tasks"
    id = Column(Integer, primary_key=True, autoincrement=True)
    video_id = Column(String, nullable=False)
    platform = Column(String, nullable=False)
    task_id = Column(String, unique=True, nullable=False)
    created_at = Column(DateTime, server_default=func.now())
```

```8:20:backend/app/db/video_task_dao.py
def insert_video_task(video_id: str, platform: str, task_id: str):
    # 教育注释：简单插入并输出日志；实际生产可考虑唯一性与幂等性处理
    db = next(get_db())
    try:
        task = VideoTask(video_id=video_id, platform=platform, task_id=task_id)
        db.add(task)
        db.commit()
        db.refresh(task)
    except Exception as e:
        logger.error(f"Failed to insert video task: {e}")
    finally:
        db.close()
```

---

## 四、代码导读（前端 Front-end）

### 4.1 入口与根路由

```1:12:BillNote_frontend/src/main.tsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'
import RootLayout from './layouts/RootLayout.tsx'
createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <RootLayout>
      <App />
    </RootLayout>
  </StrictMode>
)
```

```1:45:BillNote_frontend/src/App.tsx
function App() {
  useTaskPolling(3000) // 教育注释：任务状态轮询，驱动 UI 步骤与结果
  const { loading, initialized } = useCheckBackend() // 教育注释：后端健康检查/初始化

  useEffect(() => {
    if (initialized) {
      systemCheck() // 教育注释：后端就绪后再做系统自检，避免无效请求
    }
  }, [initialized])

  if (!initialized) {
    return <BackendInitDialog open={loading} />
  }

  return (
    <BrowserRouter>
      <Routes>
        {/* 教育注释：/ 下是主工作台，/settings 下是各配置页 */}
        ...
      </Routes>
    </BrowserRouter>
  )
}
```

### 4.2 服务层：任务创建与状态查询

```1:34:BillNote_frontend/src/services/note.ts
export const generateNote = async (data) => {
  // 教育注释：将表单数据直传后端 /generate_note；成功后返回 task_id
  const response = await request.post('/generate_note', data)
  toast.success('笔记生成任务已提交！')
  return response
}

export const get_task_status = async (task_id: string) => {
  // 教育注释：供轮询 Hook 使用，返回 status 与 result（成功时）
  return await request.get('/task_status/' + task_id)
}
```

### 4.3 轮询 Hook：驱动 UI 状态机

```6:33:BillNote_frontend/src/hooks/useTaskPolling.ts
export const useTaskPolling = (interval = 3000) => {
  const tasks = useTaskStore(state => state.tasks)
  const updateTaskContent = useTaskStore(state => state.updateTaskContent)

  useEffect(() => {
    const timer = setInterval(async () => {
      const pendingTasks = tasksRef.current.filter(t => t.status != 'SUCCESS' && t.status != 'FAILED')
      for (const task of pendingTasks) {
        const res = await get_task_status(task.id)
        const { status } = res
        // 教育注释：当状态变化时同步到 store；成功态写入 markdown/transcript/audioMeta
        if (status && status !== task.status) {
          ...
        }
      }
    }, interval)
    return () => clearInterval(timer)
  }, [interval])
}
```

### 4.4 提交表单：校验、上传与重试

```219:234:BillNote_frontend/src/pages/HomePage/components/NoteForm.tsx
const onSubmit = async (values: NoteFormValues) => {
  // 教育注释：从模型列表中映射出 provider_id；若是“重试”，沿用原 task_id
  const payload: NoteFormValues = {
    ...values,
    provider_id: modelList.find(m => m.model_name === values.model_name)!.provider_id,
    task_id: currentTaskId || '',
  }
  if (currentTaskId) {
    retryTask(currentTaskId, payload)
    return
  }
  const data = await generateNote(payload)
  addPendingTask(data.task_id, values.platform, payload)
}
```

### 4.5 展示：Markdown 渲染与步骤条

```144:155:BillNote_frontend/src/pages/HomePage/components/MarkdownViewer.tsx
if (status === 'loading') {
  // 教育注释：显示步骤条，步骤与后端 TaskStatus 一一对应
  return (
    <div className="flex h-screen w-full flex-col items-center justify-center space-y-4 text-neutral-500">
      <StepBar steps={steps} currentStep={taskStatus} />
      <Loading className="h-5 w-5" />
      <div className="text-center text-sm">
        <p className="text-lg font-bold">正在生成笔记，请稍候…</p>
      </div>
    </div>
  )
}
```

### 4.6 任务 Store：任务版本化与重试

```108:151:BillNote_frontend/src/store/taskStore/index.ts
updateTaskContent: (id, data) =>
  set(state => ({
    tasks: state.tasks.map(task => {
      if (task.id !== id) return task
      // 教育注释：当 markdown 为字符串时，自动封装为带元数据的版本数组，支持多次重生成为“版本历史”
      if (typeof data.markdown === 'string') {
        const newVersion: Markdown = { ver_id: `${task.id}-${uuidv4()}`, content: data.markdown, ... }
        const updatedMarkdown = Array.isArray(task.markdown) ? [newVersion, ...task.markdown] : [newVersion, ...[]]
        return { ...task, ...data, markdown: updatedMarkdown }
      }
      return { ...task, ...data }
    }),
  })),
```

---

## 五、建议的学习路线（7 天）

1) 本地跑通：用 B 站链接成功生成笔记；
2) 阅读后端 `routers/` 与 `services/note.py`，理解阶段状态；
3) 阅读 `downloaders/` 与 `transcriber/`，尝试替换/新增实现；
4) 阅读前端 Home 页与 `services/note.ts`，理解提交/轮询/展示；
5) 接入一个 OpenAI 兼容模型或新平台下载器；
6) Docker 化部署，联通 Nginx；
7) 整理文档，提交第一个 PR；

---

## 六、实践清单（打卡）

- 生成 2 篇不同平台的笔记
- 切换 2 种转写方案并记录耗时
- 自定义 Prompt 风格查看差异
- 新增/替换模型供应商并成功调用
- Docker 部署并通过 Nginx 提供服务


